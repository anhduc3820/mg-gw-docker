name: Build WSO2 Microgateway

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}/microgateway
  MGW_VERSION: 3.2.0
  # Link download ch√≠nh th·ª©c t·ª´ WSO2 ho·∫∑c c√≥ th·ªÉ d√πng link mirror
  # Thay ƒë·ªïi URL n√†y n·∫øu c·∫ßn
  MGW_TOOLKIT_URL: https://github.com/wso2/product-microgateway/releases/download/v3.2.0/wso2am-micro-gw-toolkit-linux-3.2.0.zip

jobs:
  build-microgateway:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up JDK 11
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '11'

      - name: Cache WSO2 Microgateway Toolkit
        id: cache-toolkit
        uses: actions/cache@v3
        with:
          path: wso2-toolkit
          key: wso2-mgw-toolkit-${{ env.MGW_VERSION }}
          restore-keys: |
            wso2-mgw-toolkit-

      - name: Download WSO2 Microgateway Toolkit (if not cached)
        if: steps.cache-toolkit.outputs.cache-hit != 'true'
        run: |
          echo "üß∞ Downloading WSO2 Microgateway Toolkit v${{ env.MGW_VERSION }}..."
          wget -q ${{ env.MGW_TOOLKIT_URL }} -O toolkit.zip

          echo "üì¶ Extracting toolkit..."
          unzip -q toolkit.zip
          
          TOOLKIT_DIR=$(find . -maxdepth 1 -type d -name "wso2am-micro-gw-toolkit*" | head -1)
          if [ -z "$TOOLKIT_DIR" ]; then
            echo "‚ùå Error: Could not find extracted toolkit directory"
            ls -la
            exit 1
          fi
          
          echo "Found toolkit directory: $TOOLKIT_DIR"
          mv "$TOOLKIT_DIR" wso2-toolkit
          rm toolkit.zip
          
          echo "‚úÖ Toolkit ready. Contents:"
          ls -la wso2-toolkit

      - name: Setup Microgateway Toolkit
        run: |
          export MGW_TOOLKIT_HOME=$(pwd)/wso2-toolkit
          export PATH=$PATH:$MGW_TOOLKIT_HOME/bin
          
          # Set permissions
          chmod +x wso2-toolkit/bin/micro-gw
          
          # Verify installation
          echo "JAVA_HOME: $JAVA_HOME"
          echo "MGW_TOOLKIT_HOME: $MGW_TOOLKIT_HOME"
          echo "Java version:"
          java -version
          echo ""
          echo "Microgateway version:"
          wso2-toolkit/bin/micro-gw version
          
          # Save to environment for next steps
          echo "MGW_TOOLKIT_HOME=$MGW_TOOLKIT_HOME" >> $GITHUB_ENV
          echo "$MGW_TOOLKIT_HOME/bin" >> $GITHUB_PATH

      - name: Initialize Microgateway Project
        run: |
          # N·∫øu ch∆∞a c√≥ project, t·∫°o m·ªõi
          if [ ! -d "external-gw" ]; then
            echo "Initializing new microgateway project..."
            micro-gw init external-gw
          fi
          
          # Copy API definitions n·∫øu c√≥
          if [ -d "api_definitions" ]; then
            echo "Copying API definitions..."
            cp -r api_definitions/* external-gw/api_definitions/ 2>/dev/null || true
          fi
          
          # List project structure
          echo "Project structure:"
          ls -la external-gw/

      - name: Build Microgateway Docker Image
        run: |
          set +e  # Cho ph√©p ti·∫øp t·ª•c n·∫øu c√≥ l·ªói
          ls -la
          echo "Building microgateway project..."
          micro-gw build external-gw
          EXIT_CODE=$?
          echo "micro-gw exited with code: $EXIT_CODE"
          
          # N·∫øu file jar ƒë√£ ƒë∆∞·ª£c t·∫°o => build th√†nh c√¥ng
          if [ -f "external-gw/target/external-gw.jar" ]; then
            echo "‚úÖ Microgateway JAR built successfully."
            exit 0
          else
            echo "‚ùå Build failed. Exit code: $EXIT_CODE"
            exit $EXIT_CODE
          fi

          docker images | grep external-gw

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Tag and Push Docker Images
        run: |
          echo "Tagging images..."
          
          # Tag v·ªõi c√°c metadata tags
          IFS=',' read -ra TAGS <<< "${{ steps.meta.outputs.tags }}"
          for tag in "${TAGS[@]}"; do
            echo "Tagging: $tag"
            docker tag external-gw:latest "$tag"
          done
          
          # Tag b·ªï sung
          docker tag external-gw:latest ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
          docker tag external-gw:latest ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.ref_name }}
          
          echo "Pushing images..."
          docker push --all-tags ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}

      - name: Test Microgateway Container
        run: |
          echo "Starting test container..."
          docker run -d --name test-mgw \
            -p 9090:9090 \
            -p 9095:9095 \
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
          
          # Wait for container to start
          echo "Waiting for container to start..."
          sleep 30
          
          # Check container status
          docker ps -a | grep test-mgw
          
          # Check logs
          echo "Container logs:"
          docker logs test-mgw
          
          # Test health endpoint (if available)
          echo "Testing health endpoint..."
          curl -k -f https://localhost:9095/health || echo "Health endpoint not available"
          
          # Cleanup
          echo "Stopping test container..."
          docker stop test-mgw
          docker rm test-mgw

      - name: Run Security Scan with Trivy
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
          format: 'sarif'
          output: 'trivy-results.sarif'
        continue-on-error: true

      - name: Upload Trivy Results
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'
        continue-on-error: true

      - name: Generate Build Summary
        if: always()
        run: |
          echo "## üöÄ Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Image Details" >> $GITHUB_STEP_SUMMARY
          echo "- **Registry**: ${{ env.REGISTRY }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Image**: ${{ env.IMAGE_NAME }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Tags**: \`${{ github.sha }}\`, \`${{ github.ref_name }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Build Info" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit**: ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch**: ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Toolkit Version**: ${{ env.MGW_VERSION }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Triggered by**: ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Pull Command" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`bash" >> $GITHUB_STEP_SUMMARY
          echo "docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY

  deploy-staging:
    needs: build-microgateway
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/develop'
    environment: staging

    steps:
      - name: Deploy to Staging
        run: |
          echo "üöÄ Deploying to staging environment..."
          echo "Image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}"
          
          # Th√™m deployment commands c·ªßa b·∫°n ·ªü ƒë√¢y
          # V√≠ d·ª• v·ªõi kubectl:
          # kubectl set image deployment/microgateway \
          #   microgateway=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }} \
          #   -n staging
          
          # Ho·∫∑c v·ªõi docker-compose:
          # export IMAGE_TAG=${{ github.sha }}
          # docker-compose -f docker-compose.staging.yml up -d
          
          echo "‚úÖ Deployment to staging completed"

  deploy-production:
    needs: build-microgateway
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    environment: production

    steps:
      - name: Deploy to Production
        run: |
          echo "üöÄ Deploying to production environment..."
          echo "Image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}"
          
          # Th√™m deployment commands c·ªßa b·∫°n ·ªü ƒë√¢y
          # V√≠ d·ª• v·ªõi kubectl:
          # kubectl set image deployment/microgateway \
          #   microgateway=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }} \
          #   -n production
          
          echo "‚úÖ Deployment to production completed"