name: Build WSO2 Microgateway

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}/microgateway
  MGW_VERSION: 3.2.0
  # Link download ch√≠nh th·ª©c t·ª´ WSO2 ho·∫∑c c√≥ th·ªÉ d√πng link mirror
  # Thay ƒë·ªïi URL n√†y n·∫øu c·∫ßn
  MGW_TOOLKIT_URL: https://github.com/wso2/product-microgateway/releases/download/v3.2.0/wso2am-micro-gw-toolkit-linux-3.2.0.zip

jobs:
  build-microgateway:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up JDK 11
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '11'

      - name: Cache WSO2 Microgateway Toolkit
        id: cache-toolkit
        uses: actions/cache@v3
        with:
          path: wso2-toolkit
          key: wso2-mgw-toolkit-${{ env.MGW_VERSION }}
          restore-keys: |
            wso2-mgw-toolkit-

      - name: Download WSO2 Microgateway Toolkit (if not cached)
        if: steps.cache-toolkit.outputs.cache-hit != 'true'
        run: |
          echo "üß∞ Downloading WSO2 Microgateway Toolkit v${{ env.MGW_VERSION }}..."
          wget -q ${{ env.MGW_TOOLKIT_URL }} -O toolkit.zip

          echo "üì¶ Extracting toolkit..."
          unzip -q toolkit.zip
          
          TOOLKIT_DIR=$(find . -maxdepth 1 -type d -name "wso2am-micro-gw-toolkit*" | head -1)
          if [ -z "$TOOLKIT_DIR" ]; then
            echo "‚ùå Error: Could not find extracted toolkit directory"
            ls -la
            exit 1
          fi
          
          echo "Found toolkit directory: $TOOLKIT_DIR"
          mv "$TOOLKIT_DIR" wso2-toolkit
          rm toolkit.zip
          
          echo "‚úÖ Toolkit ready. Contents:"
          ls -la wso2-toolkit

      - name: Setup Microgateway Toolkit
        run: |
          export MGW_TOOLKIT_HOME=$(pwd)/wso2-toolkit
          export PATH=$PATH:$MGW_TOOLKIT_HOME/bin
          
          # Set permissions
          chmod +x wso2-toolkit/bin/micro-gw
          
          # Verify installation
          echo "JAVA_HOME: $JAVA_HOME"
          echo "MGW_TOOLKIT_HOME: $MGW_TOOLKIT_HOME"
          echo "Java version:"
          java -version
          echo ""
          echo "Microgateway version:"
          wso2-toolkit/bin/micro-gw version
          
          # Save to environment for next steps
          echo "MGW_TOOLKIT_HOME=$MGW_TOOLKIT_HOME" >> $GITHUB_ENV
          echo "$MGW_TOOLKIT_HOME/bin" >> $GITHUB_PATH

      - name: Initialize Microgateway Project
        run: |
          # N·∫øu ch∆∞a c√≥ project, t·∫°o m·ªõi
          if [ ! -d "external-gw" ]; then
            echo "Initializing new microgateway project..."
            micro-gw init external-gw
          fi
          
          # Copy API definitions n·∫øu c√≥
          if [ -d "api_definitions" ]; then
            echo "Copying API definitions..."
            cp -r api_definitions/* external-gw/api_definitions/ 2>/dev/null || true
          fi
          
          # List project structure
          echo "Project structure:"
          ls -la external-gw/

      - name: Build Microgateway Docker Image
        run: |
          set +e  # Cho ph√©p ti·∫øp t·ª•c n·∫øu c√≥ l·ªói
          ls -la
          echo "Building microgateway project..."
          micro-gw build external-gw
          EXIT_CODE=$?
          echo "micro-gw exited with code: $EXIT_CODE"
          
          # N·∫øu file jar ƒë√£ ƒë∆∞·ª£c t·∫°o => build th√†nh c√¥ng
          if [ -f "external-gw/target/external-gw.jar" ]; then
            echo "‚úÖ Microgateway JAR built successfully."
            exit 0
          else
            echo "‚ùå Build failed. Exit code: $EXIT_CODE"
            exit $EXIT_CODE
          fi

      - name: Build and push Docker image
        run: |
          # N·∫øu file jar ƒë√£ ƒë∆∞·ª£c t·∫°o => build th√†nh c√¥ng
          if [ -f "Dockerfile" ]; then
            echo "‚úÖ Dockerfile exist."
            docker build -t external-mgw .
            exit 0
          else
            echo "‚ùå Build failed. Dockerfile not found Exit code: $EXIT_CODE"
            exit $EXIT_CODE
          fi

      - name: Test Microgateway Container
        run: |
          docker images
          echo "Starting test container..."
          docker run -d --name test-mgw \
            -p 9090:9090 \
            -p 9095:9095 \
            external-mgw
          
          # Wait for container to start
          echo "Waiting for container to start..."
          sleep 30
          
          # Check container status
          docker ps -a | grep test-mgw
          
          # Check logs
          echo "Container logs:"
          docker logs test-mgw
          
          # Test health endpoint (if available)
          echo "Testing health endpoint..."
          curl -k -f https://localhost:9095/health || echo "Health endpoint not available"
          
          # Cleanup
          echo "Stopping test container..."
          docker stop test-mgw
          docker rm test-mgw

  deploy-staging:
    needs: build-microgateway
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/develop'
    environment: staging

    steps:
      - name: Deploy to Staging
        run: |
          echo "üöÄ Deploying to staging environment..."
          echo "Image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}"
          
          # Th√™m deployment commands c·ªßa b·∫°n ·ªü ƒë√¢y
          # V√≠ d·ª• v·ªõi kubectl:
          # kubectl set image deployment/microgateway \
          #   microgateway=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }} \
          #   -n staging
          
          # Ho·∫∑c v·ªõi docker-compose:
          # export IMAGE_TAG=${{ github.sha }}
          # docker-compose -f docker-compose.staging.yml up -d
          
          echo "‚úÖ Deployment to staging completed"

  deploy-production:
    needs: build-microgateway
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    environment: production

    steps:
      - name: Deploy to Production
        run: |
          echo "üöÄ Deploying to production environment..."
          echo "Image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}"
          
          # Th√™m deployment commands c·ªßa b·∫°n ·ªü ƒë√¢y
          # V√≠ d·ª• v·ªõi kubectl:
          # kubectl set image deployment/microgateway \
          #   microgateway=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }} \
          #   -n production
          
          echo "‚úÖ Deployment to production completed"